---
description: "PHP best practices, modern patterns, and development guidelines"
globs: ["**/*.{php,phtml}"]
alwaysApply: false
---

# PHP Rules

## Modern PHP Syntax and Features
- Use PHP 8.0+ features: typed properties, named arguments, match expressions, nullsafe operator
- Always declare strict types with declare(strict_types=1) at the top of files
- Use proper type declarations for function parameters and return types
- Prefer arrow functions for simple callbacks when appropriate
- Use null coalescing operator (??) and null coalescing assignment (??=)
- Use spaceship operator (<=>) for comparisons when suitable
- Leverage union types and intersection types for better type safety

## File Size and Code Organization
- Keep PHP files manageable: aim for under 300 lines per file
- Follow Single Responsibility Principle: one class per file, one purpose per class
- Use PSR-4 autoloading for proper namespace and file organization
- Separate concerns: controllers, models, services, and utilities in different files
- Extract complex business logic into dedicated service classes
- Use meaningful file and class names that describe their purpose
- Group related functionality into logical namespaces
- **Component extraction**: Create reusable UI components (buttons, cards, info displays) to eliminate code duplication
- **DRY principle implementation**: Extract common patterns into utility functions for consistent reuse
- **Centralized includes**: Use shared configuration and component files to maintain consistency across templates
- **Utility functions**: Create helper functions for common tasks (phone formatting, HTML escaping, input validation)

## Object-Oriented Programming
- Follow SOLID principles, especially Single Responsibility and Dependency Injection
- Use proper visibility modifiers (private, protected, public) appropriately
- Prefer composition over inheritance for flexible design
- Use interfaces for contracts and dependency injection
- Implement proper constructor property promotion in PHP 8.0+
- Use readonly properties when data shouldn't change after construction
- Apply proper encapsulation - avoid public properties unless necessary

## Error Handling and Security
- Use try-catch blocks for exception handling, not error suppression with @
- Create custom exception classes for different error types
- Validate and sanitize all user input before processing
- Use prepared statements for all database queries to prevent SQL injection
- Never trust user input - validate, filter, and escape appropriately
- Use password_hash() and password_verify() for password handling
- Implement proper CSRF protection for forms
- Use htmlspecialchars() for output escaping to prevent XSS
- **Centralized error handling**: Create dedicated error handler files for consistent error management
- **Input validation utilities**: Implement reusable validation functions for common data types
- **Safe output functions**: Create wrapper functions for htmlspecialchars and other escaping methods
- **Router error handling**: Implement proper 404 handling and static file serving in routing logic

## Database and Data Handling
- Always use prepared statements with PDO or MySQLi
- Use parameter binding for all dynamic SQL queries
- Implement proper database connection handling with try-catch
- Use transactions for operations that need atomicity
- Avoid SELECT * queries - specify only needed columns
- Use proper indexing and optimize queries for performance
- Implement connection pooling and proper connection cleanup
- Use database migrations for schema changes

## Laravel-Specific Patterns (if using Laravel)
- Use Eloquent ORM effectively with proper relationships
- Leverage Laravel's service container for dependency injection
- Use form requests for validation logic
- Implement proper middleware for authentication and authorization
- Use Laravel's built-in security features (CSRF, password hashing, encryption)
- Follow Laravel naming conventions for routes, controllers, and models
- Use Artisan commands for repetitive tasks and maintenance
- Implement proper job queues for background processing

## Performance and Optimization
- Use opcode caching (OPcache) in production environments
- Implement proper caching strategies (Redis, Memcached, file-based)
- Avoid N+1 query problems with eager loading
- Use database indexing effectively for query optimization
- Implement proper session handling and storage
- Use lazy loading for expensive operations when possible
- Profile and monitor application performance regularly
- Optimize autoloading and reduce file includes

## Code Quality and Standards
- Follow PSR-12 coding standards for consistent formatting
- Use meaningful variable and function names that explain intent
- Write DocBlocks for all classes, methods, and complex functions
- Keep functions small and focused on a single task
- Use constants for magic numbers and configuration values
- Implement proper logging with PSR-3 compliant loggers
- Use static analysis tools like PHPStan or Psalm
- Write unit tests for business logic and critical functionality

## Modern PHP Development Practices
- Use Composer for dependency management and autoloading
- Implement proper environment configuration with .env files
- Use version control effectively with meaningful commit messages
- Follow semantic versioning for package releases
- Implement proper API design with RESTful principles
- Use proper HTTP status codes and response formats
- Implement rate limiting and API throttling when needed
- Use proper JSON handling with json_encode/json_decode and error checking

## Testing and Quality Assurance
- Write testable code by avoiding global state and dependencies
- Use dependency injection for easier mocking and testing
- Implement unit tests with PHPUnit for critical business logic
- Use feature tests for end-to-end functionality verification
- Mock external dependencies and services in tests
- Maintain good test coverage without obsessing over 100%
- Use data providers for testing multiple scenarios
- Implement continuous integration with automated testing

## Memory Management and Performance
- Be mindful of memory usage with large datasets
- Use generators for processing large amounts of data
- Unset variables when dealing with large objects or arrays
- Avoid memory leaks by properly cleaning up resources
- Use appropriate data structures for different use cases
- Implement proper pagination for large result sets
- Use streaming for file uploads and downloads
- Monitor and optimize memory usage in production

## Framework Integration and APIs
- Design clean, RESTful API endpoints with proper HTTP methods
- Implement proper API authentication (JWT, OAuth, API keys)
- Use proper HTTP status codes for different response types
- Implement request/response validation and transformation
- Use proper CORS handling for cross-origin requests
- Design consistent API response formats
- Implement proper API versioning strategies
- Use OpenAPI/Swagger for API documentation when appropriate